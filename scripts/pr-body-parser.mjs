#!/usr/bin/env node

/**
 * PR Body Parser Script
 * This script extracts and prints the pull request body and metadata
 * Also creates a markdown file in the markfiles folder
 */

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

function main() {
    console.log('üöÄ PR Body Parser Script Started');
    console.log('================================');
    
    // Get PR information from environment variables
    const prBody = process.env.PR_BODY || 'No PR body provided';
    const prNumber = process.env.PR_NUMBER || 'Unknown';
    const prTitle = process.env.PR_TITLE || 'Unknown';
    const prAuthor = process.env.PR_AUTHOR || 'Unknown';
    
    // Print PR metadata
    console.log(`üìù Pull Request #${prNumber}`);
    console.log(`üìå Title: ${prTitle}`);
    console.log(`üë§ Author: ${prAuthor}`);
    console.log(`üìÖ Timestamp: ${new Date().toISOString()}`);
    console.log('');
    
    // Print PR body
    console.log('üìÑ Pull Request Body:');
    console.log('=====================');
    
    if (prBody && prBody.trim() !== '' && prBody !== 'null') {
        // Parse and format the PR body
        const formattedBody = formatPRBody(prBody);
        console.log(formattedBody);
    } else {
        console.log('‚ùå No description provided in the pull request body.');
    }
    
    console.log('');
    console.log('=====================');
    
    // Optional: Save PR body to a file for other scripts to use
    const outputDir = path.join(process.cwd(), 'temp');
    if (!fs.existsSync(outputDir)) {
        fs.mkdirSync(outputDir, { recursive: true });
    }
    
    const prData = {
        number: prNumber,
        title: prTitle,
        author: prAuthor,
        body: prBody,
        timestamp: new Date().toISOString()
    };
    
    const outputFile = path.join(outputDir, 'pr-data.json');
    fs.writeFileSync(outputFile, JSON.stringify(prData, null, 2));
    console.log(`üíæ PR data saved to: ${outputFile}`);
    
    // Create markdown file in markfiles folder
    createMarkdownFile(prData);
    
    // Extract checklist items if present
    extractChecklist(prBody);
    
    // Extract issue references
    extractIssueReferences(prBody);
    
    console.log('‚úÖ PR Body Parser Script Completed');
}

function formatPRBody(body) {
    // Replace common markdown elements for better console display
    let formatted = body
        .replace(/###\s*/g, 'üî∏ ')
        .replace(/##\s*/g, 'üîπ ')
        .replace(/#\s*/g, 'üî∂ ')
        .replace(/\*\*(.*?)\*\*/g, 'üî• $1')
        .replace(/\*(.*?)\*/g, '‚ú® $1')
        .replace(/`(.*?)`/g, 'üíª $1')
        .replace(/```[\s\S]*?```/g, '[CODE BLOCK]')
        .replace(/\[(x|X)\]/g, '‚úÖ')
        .replace(/\[ \]/g, '‚òê');
    
    return formatted;
}

function createMarkdownFile(prData) {
    console.log('üìù Creating markdown file...');
    
    // Create markfiles directory if it doesn't exist
    const markfilesDir = path.join(process.cwd(), 'markfiles');
    if (!fs.existsSync(markfilesDir)) {
        fs.mkdirSync(markfilesDir, { recursive: true });
        console.log(`üìÅ Created markfiles directory: ${markfilesDir}`);
    }
    
    // Generate filename with timestamp to avoid conflicts
    const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
    const filename = `PR-${prData.number}-${timestamp}.md`;
    const filepath = path.join(markfilesDir, filename);
    
    // Generate markdown content
    const markdownContent = generateMarkdownContent(prData);
    
    // Write markdown file
    try {
        fs.writeFileSync(filepath, markdownContent, 'utf8');
        console.log(`üìÑ Markdown file created: ${filepath}`);
        console.log(`üìä File size: ${fs.statSync(filepath).size} bytes`);
    } catch (error) {
        console.error(`‚ùå Error creating markdown file: ${error.message}`);
    }
}

function generateMarkdownContent(prData) {
    const { number, title, author, body, timestamp } = prData;
    
    // Create comprehensive markdown content
    const markdownContent = `# Pull Request #${number}

## üìù Pull Request Details

**Title:** ${title}
**Author:** [@${author}](https://github.com/${author})
**Created:** ${new Date(timestamp).toLocaleString()}
**PR Number:** #${number}

---

## üìÑ Description

${body && body.trim() !== '' && body !== 'null' ? body : '_No description provided._'}

---

## üìä Pull Request Metadata

| Field | Value |
|-------|-------|
| PR Number | #${number} |
| Title | ${title} |
| Author | @${author} |
| Created At | ${new Date(timestamp).toLocaleString()} |
| Status | Open |

---

## üîç Analysis

### Checklist Items
${extractChecklistForMarkdown(body)}

### Issue References
${extractIssueReferencesForMarkdown(body)}

### Summary
${generateSummary(body)}

---

*This file was automatically generated by the PR Body Parser Script on ${new Date(timestamp).toLocaleString()}*
`;

    return markdownContent;
}

function extractChecklist(body) {
    const checklistItems = body.match(/- \[(x|X| )\] .+/g);
    
    if (checklistItems && checklistItems.length > 0) {
        console.log('üìã Checklist Items Found:');
        checklistItems.forEach((item, index) => {
            const isChecked = item.includes('[x]') || item.includes('[X]');
            const itemText = item.replace(/- \[(x|X| )\] /, '');
            console.log(`   ${index + 1}. ${isChecked ? '‚úÖ' : '‚òê'} ${itemText}`);
        });
        console.log('');
    }
}

function extractChecklistForMarkdown(body) {
    const checklistItems = body.match(/- \[(x|X| )\] .+/g);
    
    if (!checklistItems || checklistItems.length === 0) {
        return '_No checklist items found._';
    }
    
    let checklistMd = '\n';
    checklistItems.forEach((item, index) => {
        const isChecked = item.includes('[x]') || item.includes('[X]');
        const itemText = item.replace(/- \[(x|X| )\] /, '');
        checklistMd += `${index + 1}. ${isChecked ? '‚úÖ' : '‚òê'} ${itemText}\n`;
    });
    
    return checklistMd;
}

function extractIssueReferences(body) {
    const issueRefs = body.match(/#\d+/g);
    const fixesRefs = body.match(/(?:fixes|closes|resolves)\s+#\d+/gi);
    
    if (issueRefs && issueRefs.length > 0) {
        console.log('üîó Issue References Found:');
        const uniqueRefs = [...new Set(issueRefs)];
        uniqueRefs.forEach(ref => {
            console.log(`   ${ref}`);
        });
        console.log('');
    }
    
    if (fixesRefs && fixesRefs.length > 0) {
        console.log('üîß Issues to be Fixed/Closed:');
        fixesRefs.forEach(ref => {
            console.log(`   ${ref}`);
        });
        console.log('');
    }
}

function extractIssueReferencesForMarkdown(body) {
    const issueRefs = body.match(/#\d+/g);
    const fixesRefs = body.match(/(?:fixes|closes|resolves)\s+#\d+/gi);
    
    if ((!issueRefs || issueRefs.length === 0) && (!fixesRefs || fixesRefs.length === 0)) {
        return '_No issue references found._';
    }
    
    let referencesMd = '\n';
    
    if (issueRefs && issueRefs.length > 0) {
        referencesMd += '**Referenced Issues:**\n';
        const uniqueRefs = [...new Set(issueRefs)];
        uniqueRefs.forEach(ref => {
            referencesMd += `- ${ref}\n`;
        });
        referencesMd += '\n';
    }
    
    if (fixesRefs && fixesRefs.length > 0) {
        referencesMd += '**Issues to be Fixed/Closed:**\n';
        fixesRefs.forEach(ref => {
            referencesMd += `- ${ref}\n`;
        });
    }
    
    return referencesMd;
}

function generateSummary(body) {
    if (!body || body.trim() === '' || body === 'null') {
        return '_No summary available - PR body is empty._';
    }
    
    const wordCount = body.split(/\s+/).length;
    const lineCount = body.split('\n').length;
    const hasCodeBlocks = body.includes('```');
    const hasImages = body.includes('![') || body.includes('<img');
    const hasLinks = body.includes('[') && body.includes('](');
    
    return `
- **Word Count:** ${wordCount}
- **Line Count:** ${lineCount}
- **Contains Code Blocks:** ${hasCodeBlocks ? 'Yes' : 'No'}
- **Contains Images:** ${hasImages ? 'Yes' : 'No'}
- **Contains Links:** ${hasLinks ? 'Yes' : 'No'}
`;
}

// Handle errors gracefully
process.on('uncaughtException', (error) => {
    console.error('‚ùå Script error:', error.message);
    process.exit(1);
});

process.on('unhandledRejection', (reason, promise) => {
    console.error('‚ùå Unhandled rejection at:', promise, 'reason:', reason);
    process.exit(1);
});

// Run the main function - ES module way to detect if this file is being run directly
if (import.meta.url === `file://${process.argv[1]}`) {
    main();
}

export { main, formatPRBody, extractChecklist, extractIssueReferences, createMarkdownFile, generateMarkdownContent };
